{"paragraphs":[{"text":"%md\n\n## Magellan\n\nMagellan es un motor de ejecución distribuida para análisis geoespacial en big data. Se implementa sobre Apache Spark y aprovecha al máximo las modernas técnicas de bases de datos, como el diseño eficiente de datos, la generación de códigos y la optimización de consultas para optimizar las consultas geoespaciales.\n\nPermite escribir sql estándar o consultas de data frames para evaluar expresiones geométricas mientras el motor de ejecución se encarga de colocar datos de manera eficiente en la memoria durante el procesamiento de consultas, seleccionando el plan de consulta correcto, optimizando la ejecución de consultas con índices espaciales eficientes mientras presenta un abstracción declarativa para el desarrollador.\n\nHa sido desarrollado por Ram Sriharsha, actualmente se encuentra en la versión 1.0.5 y el unico lenguaje soportado (por el momento) es Scala. Puede descargarse desde este [link](https://spark-packages.org/package/harsha2010/magellan), para más información acceder al repositorio en [GitHub](https://github.com/harsha2010/magellan)","dateUpdated":"2018-07-27T21:48:53+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>Magellan</h2>\n<p>Magellan es un motor de ejecución distribuida para análisis geoespacial en big data. Se implementa sobre Apache Spark y aprovecha al máximo las modernas técnicas de bases de datos, como el diseño eficiente de datos, la generación de códigos y la optimización de consultas para optimizar las consultas geoespaciales.</p>\n<p>Permite escribir sql estándar o consultas de data frames para evaluar expresiones geométricas mientras el motor de ejecución se encarga de colocar datos de manera eficiente en la memoria durante el procesamiento de consultas, seleccionando el plan de consulta correcto, optimizando la ejecución de consultas con índices espaciales eficientes mientras presenta un abstracción declarativa para el desarrollador.</p>\n<p>Ha sido desarrollado por Ram Sriharsha, actualmente se encuentra en la versión 1.0.5 y el unico lenguaje soportado (por el momento) es Scala. Puede descargarse desde este <a href=\"https://spark-packages.org/package/harsha2010/magellan\">link</a>, para más información acceder al repositorio en <a href=\"https://github.com/harsha2010/magellan\">GitHub</a></p>\n"}]},"apps":[],"jobName":"paragraph_1532728133144_1866015240","id":"20180725-205525_1514663641","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:479"},{"text":"%md\n\n### Formatos soportados\n<br>\n\n\n#### ESRI Shapefile\n\nUn shapefile almacena geometría no topológica e información de atributos para las características espaciales en un conjunto de datos. La geometría de una característica se almacena como una forma que comprende un conjunto de coordenadas de vectores. Los Shapefiles se componen de varios archivos individuales.\n\nEjemplo:\n\n* **Main file:** counties.shp\n* **Index file:** counties.shx\n* **dBASE table:** counties.dbf\n\nEl archivo principal (.shp) contiene un encabezado de archivo de longitud fija seguido de registros de longitud variable. Cada registro de longitud variable se compone de un encabezado de registro de longitud fija seguido de contenido de registro de longitud variable.\n\nEstructura de un punto\n\n    Point\n    {\n    Double X // X coordinate\n    Double Y // Y coordinate\n    }\n\n<br>\n\n#### GeoJSON\n\nGeoJSON admite los siguientes tipos de geometría: Point, LineString, Polygon, MultiPoint, MultiLineString y MultiPolygon. Los objetos geométricos con propiedades adicionales son objetos \"Feature\". Los conjuntos de Feature están contenidos por objetos \"FeatureCollection\".\n\nEjemplo\n```json\n{\n  \"type\": \"Feature\",\n  \"geometry\": {\n    \"type\": \"Point\",\n    \"coordinates\": [125.6, 10.1]\n  },\n  \"properties\": {\n    \"name\": \"Dinagat Islands\"\n  }\n}\n```\n<br>\n\n#### OSM-XML\n\nLos datos de OSM (openstreetmap) se pueden almacenar de muchas maneras diferentes (binarios, bases de datos, XML, etc.) y no existe un estándar real. Sin embargo, para el uso simple off-line, el formato XML es el más común.\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<osm version=\"0.6\" generator=\"CGImap 0.0.2\">\n <bounds minlat=\"54.0889580\" minlon=\"12.2487570\" maxlat=\"54.0913900\" maxlon=\"12.2524800\"/>\n <node id=\"298884269\" lat=\"54.0901746\" lon=\"12.2482632\" user=\"SvenHRO\" uid=\"46882\" visible=\"true\" version=\"1\" changeset=\"676636\" timestamp=\"2008-09-21T21:37:45Z\"/>\n <node id=\"261728686\" lat=\"54.0906309\" lon=\"12.2441924\" user=\"PikoWinter\" uid=\"36744\" visible=\"true\" version=\"1\" changeset=\"323878\" timestamp=\"2008-05-03T13:39:23Z\"/>\n <node id=\"1831881213\" version=\"1\" changeset=\"12370172\" lat=\"54.0900666\" lon=\"12.2539381\" user=\"lafkor\" uid=\"75625\" visible=\"true\" timestamp=\"2012-07-20T09:43:19Z\">\n  <tag k=\"name\" v=\"Neu Broderstorf\"/>\n  <tag k=\"traffic_sign\" v=\"city_limit\"/>\n </node>\n ...\n</osm>\n```\n\n<br>\n\n#### WKT\nLa representación Well Known Text o de texto conocido (también llamado WKT en su acrónimo inglés) es una codificación o sintaxis en formato ASCII estandarizada diseñada para describir objetos espaciales expresados de forma vectorial. Los objetos que es capaz de describir el formato WKT son los siguientes: punto, multipunto, línea, multilínea, polígono, multipolígono, colecciones de geometría, puntos en 3 y 4 dimensiones.\n\nEjemplo\n\n    GEOMETRYCOLLECTION(POINT(4 6),LINESTRING(4 6,7 10),MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)),((15 5, 40 10, 10 20, 5 10, 15 5))))\n","dateUpdated":"2018-07-27T21:48:53+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h3>Formatos soportados</h3>\n<p><br></p>\n<h4>ESRI Shapefile</h4>\n<p>Un shapefile almacena geometría no topológica e información de atributos para las características espaciales en un conjunto de datos. La geometría de una característica se almacena como una forma que comprende un conjunto de coordenadas de vectores. Los Shapefiles se componen de varios archivos individuales.</p>\n<p>Ejemplo:</p>\n<ul>\n<li><strong>Main file:</strong> counties.shp</li>\n<li><strong>Index file:</strong> counties.shx</li>\n<li><strong>dBASE table:</strong> counties.dbf</li>\n</ul>\n<p>El archivo principal (.shp) contiene un encabezado de archivo de longitud fija seguido de registros de longitud variable. Cada registro de longitud variable se compone de un encabezado de registro de longitud fija seguido de contenido de registro de longitud variable.</p>\n<p>Estructura de un punto</p>\n<pre><code>Point\n{\nDouble X // X coordinate\nDouble Y // Y coordinate\n}\n</code></pre>\n<p><br></p>\n<h4>GeoJSON</h4>\n<p>GeoJSON admite los siguientes tipos de geometría: Point, LineString, Polygon, MultiPoint, MultiLineString y MultiPolygon. Los objetos geométricos con propiedades adicionales son objetos &ldquo;Feature&rdquo;. Los conjuntos de Feature están contenidos por objetos &ldquo;FeatureCollection&rdquo;.</p>\n<p>Ejemplo</p>\n<pre><code class=\"json\">{\n  \"type\": \"Feature\",\n  \"geometry\": {\n    \"type\": \"Point\",\n    \"coordinates\": [125.6, 10.1]\n  },\n  \"properties\": {\n    \"name\": \"Dinagat Islands\"\n  }\n}\n</code></pre>\n<p><br></p>\n<h4>OSM-XML</h4>\n<p>Los datos de OSM (openstreetmap) se pueden almacenar de muchas maneras diferentes (binarios, bases de datos, XML, etc.) y no existe un estándar real. Sin embargo, para el uso simple off-line, el formato XML es el más común.</p>\n<pre><code class=\"xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;osm version=\"0.6\" generator=\"CGImap 0.0.2\"&gt;\n &lt;bounds minlat=\"54.0889580\" minlon=\"12.2487570\" maxlat=\"54.0913900\" maxlon=\"12.2524800\"/&gt;\n &lt;node id=\"298884269\" lat=\"54.0901746\" lon=\"12.2482632\" user=\"SvenHRO\" uid=\"46882\" visible=\"true\" version=\"1\" changeset=\"676636\" timestamp=\"2008-09-21T21:37:45Z\"/&gt;\n &lt;node id=\"261728686\" lat=\"54.0906309\" lon=\"12.2441924\" user=\"PikoWinter\" uid=\"36744\" visible=\"true\" version=\"1\" changeset=\"323878\" timestamp=\"2008-05-03T13:39:23Z\"/&gt;\n &lt;node id=\"1831881213\" version=\"1\" changeset=\"12370172\" lat=\"54.0900666\" lon=\"12.2539381\" user=\"lafkor\" uid=\"75625\" visible=\"true\" timestamp=\"2012-07-20T09:43:19Z\"&gt;\n  &lt;tag k=\"name\" v=\"Neu Broderstorf\"/&gt;\n  &lt;tag k=\"traffic_sign\" v=\"city_limit\"/&gt;\n &lt;/node&gt;\n ...\n&lt;/osm&gt;\n</code></pre>\n<p><br></p>\n<h4>WKT</h4>\n<p>La representación Well Known Text o de texto conocido (también llamado WKT en su acrónimo inglés) es una codificación o sintaxis en formato ASCII estandarizada diseñada para describir objetos espaciales expresados de forma vectorial. Los objetos que es capaz de describir el formato WKT son los siguientes: punto, multipunto, línea, multilínea, polígono, multipolígono, colecciones de geometría, puntos en 3 y 4 dimensiones.</p>\n<p>Ejemplo</p>\n<pre><code>GEOMETRYCOLLECTION(POINT(4 6),LINESTRING(4 6,7 10),MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)),((15 5, 40 10, 10 20, 5 10, 15 5))))\n</code></pre>\n"}]},"apps":[],"jobName":"paragraph_1532728133155_1851010033","id":"20180726-183306_1252490474","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:480"},{"text":"%md\n\n#### Paquetes a importar\n","dateUpdated":"2018-07-27T21:48:53+0000","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h4>Paquetes a importar</h4>\n"}]},"apps":[],"jobName":"paragraph_1532728133156_1849086288","id":"20180727-164536_331796901","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:481"},{"text":"import magellan.{Point, Polygon, Line, PolyLine}\nimport org.apache.spark.sql.magellan.dsl.expressions._\nimport org.apache.spark.sql.types._","dateUpdated":"2018-07-27T21:49:04+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"import magellan.{Point, Polygon, Line, PolyLine}\nimport org.apache.spark.sql.magellan.dsl.expressions._\nimport org.apache.spark.sql.types._\n"}]},"apps":[],"jobName":"paragraph_1532728133157_1848701539","id":"20180723-161621_1016585704","dateCreated":"2018-07-27T21:48:53+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:482","user":"anonymous","dateFinished":"2018-07-27T21:49:50+0000","dateStarted":"2018-07-27T21:49:05+0000"},{"text":"%md\n\n#### Data Structure: Point\n\nSe crearán los siguientes puntos: (-1.0, -1.0), (-1.0, 1.0), (0.5, -0.5)\n\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/O7S9C3V.png\" style=\"width: 40%; height: 40%\">\n</p>","dateUpdated":"2018-07-27T21:48:53+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h4>Data Structure: Point</h4>\n<p>Se crearán los siguientes puntos: (-1.0, -1.0), (-1.0, 1.0), (0.5, -0.5)</p>\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/O7S9C3V.png\" style=\"width: 40%; height: 40%\">\n</p>\n"}]},"apps":[],"jobName":"paragraph_1532728133157_1848701539","id":"20180726-183200_1045366592","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:483"},{"text":"val points = sc.parallelize(Seq((-1.0, -1.0), (-1.0, 1.0), (0.5, -0.5))).toDF(\"x\", \"y\").select(point($\"x\", $\"y\").as(\"point\"))\n\npoints.show()","dateUpdated":"2018-07-27T21:48:53+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"points: org.apache.spark.sql.DataFrame = [point: point]\n+-----------------+\n|            point|\n+-----------------+\n|Point(-1.0, -1.0)|\n| Point(-1.0, 1.0)|\n| Point(0.5, -0.5)|\n+-----------------+\n\n"}]},"apps":[],"jobName":"paragraph_1532728133158_1849855786","id":"20180723-161630_620411280","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:484"},{"text":"%md\n\n#### Data Structure: Polygon\n\nSe creará el siguiente polígono con los siguientes puntos: (1.0, 1.0),(1.0, -1.0),(-1.0, -1.0),(-1.0, 1.0)\n\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/eI9PtQh.png\" style=\"width: 40%; height: 40%\">\n</p>","dateUpdated":"2018-07-27T21:48:53+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h4>Data Structure: Polygon</h4>\n<p>Se creará el siguiente polígono con los siguientes puntos: (1.0, 1.0),(1.0, -1.0),(-1.0, -1.0),(-1.0, 1.0)</p>\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/eI9PtQh.png\" style=\"width: 40%; height: 40%\">\n</p>\n"}]},"apps":[],"jobName":"paragraph_1532728133158_1849855786","id":"20180726-183330_476514705","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:485"},{"text":"case class PolygonRecord(polygon: magellan.Polygon)\n\nval square = Array(Point(1.0, 1.0), Point(1.0, -1.0),\n Point(-1.0, -1.0), Point(-1.0, 1.0),\n Point(1.0, 1.0))\nval polygons = sc.parallelize(Seq(\n    PolygonRecord(Polygon(Array(0), square))\n  )).toDF()\n  \npolygons.show()","dateUpdated":"2018-07-27T21:48:53+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"defined class PolygonRecord\nsquare: Array[magellan.Point] = Array(Point(1.0, 1.0), Point(1.0, -1.0), Point(-1.0, -1.0), Point(-1.0, 1.0), Point(1.0, 1.0))\npolygons: org.apache.spark.sql.DataFrame = [polygon: polygon]\n+--------------------+\n|             polygon|\n+--------------------+\n|magellan.Polygon@...|\n+--------------------+\n\n"}]},"apps":[],"jobName":"paragraph_1532728133158_1849855786","id":"20180723-161738_977531204","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:486"},{"text":"%md\n\n#### Data Structure: Line\n\nSe creará la siguiente línea: (1.0, 1.0),(1.0, -1.0)\n\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/tOIOGH7.png\" style=\"width: 40%; height: 40%\">\n</p>","dateUpdated":"2018-07-27T21:48:53+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h4>Data Structure: Line</h4>\n<p>Se creará la siguiente línea: (1.0, 1.0),(1.0, -1.0)</p>\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/tOIOGH7.png\" style=\"width: 40%; height: 40%\">\n</p>\n"}]},"apps":[],"jobName":"paragraph_1532728133159_1849471037","id":"20180726-184517_1894027138","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:487"},{"text":"case class LineExample(line: magellan.Line)\n\nval line = Line(Point(1.0, 1.0), Point(1.0, -1.0))\n\nval lines = sc.parallelize(Seq(\n      LineExample(line)\n    )).toDF()\n    \nlines.show()","dateUpdated":"2018-07-27T21:48:53+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"defined class LineExample\nline: magellan.Line = Line(Point(1.0, 1.0), Point(1.0, -1.0))\nlines: org.apache.spark.sql.DataFrame = [line: line]\n+--------------------+\n|                line|\n+--------------------+\n|Line(Point(1.0, 1...|\n+--------------------+\n\n"}]},"apps":[],"jobName":"paragraph_1532728133159_1849471037","id":"20180726-184527_1883264046","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:488"},{"text":"%md\n\n#### Data Structure: PolyLine\n\nSe creará el siguiente polyline: (1.0, 1.0),(1.0, -1.0),(-1.0, -1.0),(-1.0, 1.0)\n\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/gyoYijF.png\" style=\"width: 40%; height: 40%\">\n</p>","dateUpdated":"2018-07-27T21:48:53+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h4>Data Structure: PolyLine</h4>\n<p>Se creará el siguiente polyline: (1.0, 1.0),(1.0, -1.0),(-1.0, -1.0),(-1.0, 1.0)</p>\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/gyoYijF.png\" style=\"width: 40%; height: 40%\">\n</p>\n"}]},"apps":[],"jobName":"paragraph_1532728133160_1847547293","id":"20180726-184645_836544714","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:489"},{"text":"case class PolyLineExample(polyline: magellan.PolyLine)\n\nval path = Array(Point(1.0, 1.0), Point(1.0, -1.0),\n      Point(-1.0, -1.0), Point(-1.0, 1.0))\n\nval polylines = sc.parallelize(Seq(\n      PolyLineExample(PolyLine(Array(0), path))\n    )).toDF()\n\npolylines.show()","dateUpdated":"2018-07-27T21:48:53+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"defined class PolyLineExample\npath: Array[magellan.Point] = Array(Point(1.0, 1.0), Point(1.0, -1.0), Point(-1.0, -1.0), Point(-1.0, 1.0))\npolylines: org.apache.spark.sql.DataFrame = [polyline: polyline]\n+--------------------+\n|            polyline|\n+--------------------+\n|magellan.PolyLine...|\n+--------------------+\n\n"}]},"apps":[],"jobName":"paragraph_1532728133160_1847547293","id":"20180726-184659_1816959182","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:490"},{"text":"%md \n\n### Joins espaciales\n\nMagellan aprovecha Spark SQL y tiene soporte para joins de forma predeterminada. Sin embargo, estas uniones por defecto no son conscientes de que las columnas son geométricas, por lo que un join se realiza de la siguiente manera:\n\n    points.join(polygons).where($\"point\" within $\"polygon\")\n\nSe tratará como una unión cartesiana seguida de un predicado. En algunos casos (especialmente cuando el dataset de polígono es pequeño (entre 100 y 10000 polígonos), esto es lo suficientemente rápido. Sin embargo, cuando el número de polígonos es mucho mayor, necesitará combinaciones espaciales para permitirle escalar este cálculo.\n\nPara habilitar uniones espaciales en Magellan, se debe agregar una regla de unión espacial a Spark inyectando el siguiente código antes del join:\n\n    magellan.Utils.injectRules(spark)\n\nAdemás, durante la unión, se deberá proporcionar a Magellan una sugerencia de la precisión con la que se crearán índices para la unión. Se puede hacer anotando cualquiera de los dataframes implicados en la unión proporcionando una sugerencia de unión espacial de la siguiente manera:\n\n    var df = df.index(30) //después de la carga o\n    val df =spark.read.format(...).load(..).index(30) //durante la carga\n    \nLuego, una combinación de la forma\n\n    points.join(polygons).where($\"point\" within $\"polygon\")\n    // o de la forma\n    points.join(polygons index 30).where($\"point\" within $\"polygon\")","dateUpdated":"2018-07-27T21:48:53+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h3>Joins espaciales</h3>\n<p>Magellan aprovecha Spark SQL y tiene soporte para joins de forma predeterminada. Sin embargo, estas uniones por defecto no son conscientes de que las columnas son geométricas, por lo que un join se realiza de la siguiente manera:</p>\n<pre><code>points.join(polygons).where($\"point\" within $\"polygon\")\n</code></pre>\n<p>Se tratará como una unión cartesiana seguida de un predicado. En algunos casos (especialmente cuando el dataset de polígono es pequeño (entre 100 y 10000 polígonos), esto es lo suficientemente rápido. Sin embargo, cuando el número de polígonos es mucho mayor, necesitará combinaciones espaciales para permitirle escalar este cálculo.</p>\n<p>Para habilitar uniones espaciales en Magellan, se debe agregar una regla de unión espacial a Spark inyectando el siguiente código antes del join:</p>\n<pre><code>magellan.Utils.injectRules(spark)\n</code></pre>\n<p>Además, durante la unión, se deberá proporcionar a Magellan una sugerencia de la precisión con la que se crearán índices para la unión. Se puede hacer anotando cualquiera de los dataframes implicados en la unión proporcionando una sugerencia de unión espacial de la siguiente manera:</p>\n<pre><code>var df = df.index(30) //después de la carga o\nval df =spark.read.format(...).load(..).index(30) //durante la carga\n</code></pre>\n<p>Luego, una combinación de la forma</p>\n<pre><code>points.join(polygons).where($\"point\" within $\"polygon\")\n// o de la forma\npoints.join(polygons index 30).where($\"point\" within $\"polygon\")\n</code></pre>\n"}]},"apps":[],"jobName":"paragraph_1532728133160_1847547293","id":"20180727-181324_962721967","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:491"},{"text":"%md\n\n#### Predicado: within\n\nPara este ejemplo la operación retorna el polígono y los puntos dentro del mismo.\n\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/HxX9MDm.png\" style=\"width: 40%; height: 40%\">\n</p>","dateUpdated":"2018-07-27T21:48:53+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h4>Predicado: within</h4>\n<p>Para este ejemplo la operación retorna el polígono y los puntos dentro del mismo.</p>\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/HxX9MDm.png\" style=\"width: 40%; height: 40%\">\n</p>\n"}]},"apps":[],"jobName":"paragraph_1532728133161_1847162544","id":"20180726-183523_1834686471","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:492"},{"text":"points.join(polygons).where($\"point\" within $\"polygon\").show()","dateUpdated":"2018-07-27T21:48:53+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"+----------------+--------------------+\n|           point|             polygon|\n+----------------+--------------------+\n|Point(0.5, -0.5)|magellan.Polygon@...|\n+----------------+--------------------+\n\n"}]},"apps":[],"jobName":"paragraph_1532728133161_1847162544","id":"20180723-161803_79889234","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:493"},{"text":"%md\n\n#### Predicado: intersects\n\nPara este ejemplo la operación retorna el polígono y la linea que intersecta con el.\n\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/bSb7yWF.png\" style=\"width: 40%; height: 40%\">\n</p>","dateUpdated":"2018-07-27T21:48:53+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h4>Predicado: intersects</h4>\n<p>Para este ejemplo la operación retorna el polígono y la linea que intersecta con el.</p>\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/bSb7yWF.png\" style=\"width: 40%; height: 40%\">\n</p>\n"}]},"apps":[],"jobName":"paragraph_1532728133162_1848316791","id":"20180726-183627_62209190","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:494"},{"text":"lines.join(polygons).where($\"line\" intersects $\"polygon\").show()","dateUpdated":"2018-07-27T21:48:53+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"+--------------------+--------------------+\n|                line|             polygon|\n+--------------------+--------------------+\n|Line(Point(1.0, 1...|magellan.Polygon@...|\n+--------------------+--------------------+\n\n"}]},"apps":[],"jobName":"paragraph_1532728133162_1848316791","id":"20180723-161838_15843914","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:495"},{"text":"%md\n\nEn este otro ejemplo la operación retorna el polígono y los puntos que intersectan con el mismo.\n\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/iQCok2o.png\" style=\"width: 40%; height: 40%\">\n</p>\n","dateUpdated":"2018-07-27T21:48:53+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<p>En este otro ejemplo la operación retorna el polígono y los puntos que intersectan con el mismo.</p>\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/iQCok2o.png\" style=\"width: 40%; height: 40%\">\n</p>\n"}]},"apps":[],"jobName":"paragraph_1532728133162_1848316791","id":"20180727-183703_1409634963","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:496"},{"text":"points.join(polygons).where($\"point\" intersects $\"polygon\").show()\n","dateUpdated":"2018-07-27T21:48:53+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"+-----------------+--------------------+\n|            point|             polygon|\n+-----------------+--------------------+\n|Point(-1.0, -1.0)|magellan.Polygon@...|\n| Point(-1.0, 1.0)|magellan.Polygon@...|\n+-----------------+--------------------+\n\n"}]},"apps":[],"jobName":"paragraph_1532728133163_1847932042","id":"20180727-183918_1856697706","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:497"},{"text":"%md\n\n#### Predicado: contains\n\nDado que contains es una expresión sobrecargada (contains se usa para verificar la contención de strings mediante Spark SQL), Magellan usa la expresión binaria ***>?*** para verificar el contenido de una forma.\n\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/HxX9MDm.png\" style=\"width: 40%; height: 40%\">\n</p>","dateUpdated":"2018-07-27T21:48:53+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h4>Predicado: contains</h4>\n<p>Dado que contains es una expresión sobrecargada (contains se usa para verificar la contención de strings mediante Spark SQL), Magellan usa la expresión binaria <strong><em>>?</em></strong> para verificar el contenido de una forma.</p>\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/HxX9MDm.png\" style=\"width: 40%; height: 40%\">\n</p>\n"}]},"apps":[],"jobName":"paragraph_1532728133163_1847932042","id":"20180726-183648_2094740227","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:498"},{"text":"points.join(polygons).where($\"polygon\" >? $\"point\").show()\n","dateUpdated":"2018-07-27T21:48:53+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"+----------------+--------------------+\n|           point|             polygon|\n+----------------+--------------------+\n|Point(0.5, -0.5)|magellan.Polygon@...|\n+----------------+--------------------+\n\n"}]},"apps":[],"jobName":"paragraph_1532728133164_1846008297","id":"20180726-185135_1965385082","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:499"},{"text":"%md \n\n### Z-order curve\n\nLos índices espaciales organizan los datos en estructuras que se pueden atravesar rápidamente para acceder a los datos geográficos subyacentes de manera eficiente. Los índices espaciales soportaron en Magellan usan **Z-order curve**.\n\nEl ordenamiento Z-order curve (también llamado Morton order) fue introducido en 1966 por G. M. Morton y es una técnica que permite mapear datos multidimensionales en una sola dimensión, aplicado a las coordenadas, este ordenamiento define una curva de relleno de espacio que tiene forma de Z. La curva tiene algunas buenas propiedades de localidad: las coordenadas que están cerca una de la otra en el espacio N-dimensional tienen su equivalente numérico Z también cerca uno del otro.\n\nEl cálculo del número Z se realiza intercalando cada digito binario entre los valores Y y X, por ejemplo, se requiere hallar el número Z de las coordenadas  [x=97, y=214]\n\n    X value:   01100001\n    Y value:   11010110\n    Z value: Y[0]X[0]Y[1]X[1]Y[2]X[2]Y[3]X[3]... :1011011000101001\n\nUn nuevo ejemplo a continuación muestra los valores Z para el caso bidimensional con coordenadas enteras 0 ≤ x ≤ 7, 0 ≤ y ≤ 7 (se muestran tanto en decimal como en binario). El entrelazado de los valores de coordenadas binarias produce valores z binarios como se muestra. La conexión de los valores z en su orden numérico produce la curva recursiva en forma de Z.\n\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/R5Nw2QQ.png\" style=\"width: 25%; height: 25%\">\n</p>\n\nPara hacer una consulta con estos índices se puede definir un rango de los elementos que se quieren consultar, por ejemplo, teniendo como base el ejemplo anterior se quieren consultar los datos que tengan valores de X entre 2 y 3 y valores de Y entre 4 y 5, para hacer la consulta se toma el punto [x=2, y=4] como el límite mínimo ya que su valor en la curva Z aparece primero dentro del área que se quiere consulatar, luego se toma  el punto [x=3, y=5] como el límite máximo ya que es el ultimo valor Z de la curva que está dentro del área a consultar.\n\n<p align=\"center\">\n    <img  src=\"https://d2908q01vomqb2.cloudfront.net/887309d048beef83ad3eabf2a79a64a389ab1c9f/2017/02/02/DigitZ.png\" style=\"width: 25%; height: 25%\">\n</p>\n\nUna vez hecho esto, ahora se tiene un rango lineal que se puede iterar y que contiene todos los elementos en el área de consulta. El resultado cubre cuatro direcciones Z, pero eso no significa que se recuperaron cuatro elementos. Por el contrario, se ha calculado las cuatro ubicaciones posibles que podrían contener datos que coinciden con la consulta.","dateUpdated":"2018-07-27T21:48:53+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h3>Z-order curve</h3>\n<p>Los índices espaciales organizan los datos en estructuras que se pueden atravesar rápidamente para acceder a los datos geográficos subyacentes de manera eficiente. Los índices espaciales soportaron en Magellan usan <strong>Z-order curve</strong>.</p>\n<p>El ordenamiento Z-order curve (también llamado Morton order) fue introducido en 1966 por G. M. Morton y es una técnica que permite mapear datos multidimensionales en una sola dimensión, aplicado a las coordenadas, este ordenamiento define una curva de relleno de espacio que tiene forma de Z. La curva tiene algunas buenas propiedades de localidad: las coordenadas que están cerca una de la otra en el espacio N-dimensional tienen su equivalente numérico Z también cerca uno del otro.</p>\n<p>El cálculo del número Z se realiza intercalando cada digito binario entre los valores Y y X, por ejemplo, se requiere hallar el número Z de las coordenadas  [x=97, y=214]</p>\n<pre><code>X value:   01100001\nY value:   11010110\nZ value: Y[0]X[0]Y[1]X[1]Y[2]X[2]Y[3]X[3]... :1011011000101001\n</code></pre>\n<p>Un nuevo ejemplo a continuación muestra los valores Z para el caso bidimensional con coordenadas enteras 0 ≤ x ≤ 7, 0 ≤ y ≤ 7 (se muestran tanto en decimal como en binario). El entrelazado de los valores de coordenadas binarias produce valores z binarios como se muestra. La conexión de los valores z en su orden numérico produce la curva recursiva en forma de Z.</p>\n<p align=\"center\">\n    <img  src=\"https://i.imgur.com/R5Nw2QQ.png\" style=\"width: 25%; height: 25%\">\n</p>\n<p>Para hacer una consulta con estos índices se puede definir un rango de los elementos que se quieren consultar, por ejemplo, teniendo como base el ejemplo anterior se quieren consultar los datos que tengan valores de X entre 2 y 3 y valores de Y entre 4 y 5, para hacer la consulta se toma el punto [x=2, y=4] como el límite mínimo ya que su valor en la curva Z aparece primero dentro del área que se quiere consulatar, luego se toma  el punto [x=3, y=5] como el límite máximo ya que es el ultimo valor Z de la curva que está dentro del área a consultar.</p>\n<p align=\"center\">\n    <img  src=\"https://d2908q01vomqb2.cloudfront.net/887309d048beef83ad3eabf2a79a64a389ab1c9f/2017/02/02/DigitZ.png\" style=\"width: 25%; height: 25%\">\n</p>\n<p>Una vez hecho esto, ahora se tiene un rango lineal que se puede iterar y que contiene todos los elementos en el área de consulta. El resultado cubre cuatro direcciones Z, pero eso no significa que se recuperaron cuatro elementos. Por el contrario, se ha calculado las cuatro ubicaciones posibles que podrían contener datos que coinciden con la consulta.</p>\n"}]},"apps":[],"jobName":"paragraph_1532728133164_1846008297","id":"20180726-185157_617205765","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:500"},{"text":"%md \n\n### Añadir índices espaciales con Magellan\n\nDada una columna de formas, se pueden indexar las formas con una precisión determinada usando un indexador geohash haciendo lo siguiente:\n\n    df.withColumn(\"index\", $\"polygon\" index 30)\n\nEsto produce una nueva columna llamada index que es una lista de Z-Order Curvas de precisión 30.\n","dateUpdated":"2018-07-27T21:48:53+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h3>Añadir índices espaciales con Magellan</h3>\n<p>Dada una columna de formas, se pueden indexar las formas con una precisión determinada usando un indexador geohash haciendo lo siguiente:</p>\n<pre><code>df.withColumn(\"index\", $\"polygon\" index 30)\n</code></pre>\n<p>Esto produce una nueva columna llamada index que es una lista de Z-Order Curvas de precisión 30.</p>\n"}]},"apps":[],"jobName":"paragraph_1532728133164_1846008297","id":"20180727-212754_1310129657","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:501"},{"text":"val points_i = sc.parallelize(Seq((-1.0, -1.0), (-1.0, 1.0), (0.5, -0.5))).toDF(\"x\", \"y\").select(point($\"x\", $\"y\").as(\"point\")).withColumn(\"index\", $\"point\" index 30)\n\npoints_i.show()\n","dateUpdated":"2018-07-27T21:50:07+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"points_i: org.apache.spark.sql.DataFrame = [point: point, index: array<struct<curve:zordercurve,relation:string>>]\n+-----------------+--------------------+\n|            point|               index|\n+-----------------+--------------------+\n|Point(-1.0, -1.0)|[[ZOrderCurve(-1....|\n| Point(-1.0, 1.0)|[[ZOrderCurve(-1....|\n| Point(0.5, -0.5)|[[ZOrderCurve(0.4...|\n+-----------------+--------------------+\n\n"}]},"apps":[],"jobName":"paragraph_1532728133165_1845623548","id":"20180727-210632_995358915","dateCreated":"2018-07-27T21:48:53+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:502","user":"anonymous","dateFinished":"2018-07-27T21:50:18+0000","dateStarted":"2018-07-27T21:50:08+0000"},{"text":"%md\n\n### Crear índices mientras se cargan datos\n\nLas relaciones espaciales (GeoJSON, Shapefile, OSM-XML) tienen la capacidad de indexar automáticamente las geometrías mientras se cargan.\n\nPara activar esta característica, se tiene que pasar el parámetro `magellan.index = true` y opcionalmente un valor para `magellan.index.precision` (por defecto es 30) mientras carga los datos de la siguiente manera:\n\n    spark.read.format(\"magellan\")\n    .option(\"magellan.index\", \"true\")\n    .option(\"magellan.index.precision\", \"25\")\n    .load(\"$path\")\n\nEsto crea una columna adicional llamada índice que contiene la lista de Curvas Z-Order con la precisión dada que cubren cada geometría en el conjunto de datos.","dateUpdated":"2018-07-27T21:48:53+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h3>Crear índices mientras se cargan datos</h3>\n<p>Las relaciones espaciales (GeoJSON, Shapefile, OSM-XML) tienen la capacidad de indexar automáticamente las geometrías mientras se cargan.</p>\n<p>Para activar esta característica, se tiene que pasar el parámetro <code>magellan.index = true</code> y opcionalmente un valor para <code>magellan.index.precision</code> (por defecto es 30) mientras carga los datos de la siguiente manera:</p>\n<pre><code>spark.read.format(\"magellan\")\n.option(\"magellan.index\", \"true\")\n.option(\"magellan.index.precision\", \"25\")\n.load(\"$path\")\n</code></pre>\n<p>Esto crea una columna adicional llamada índice que contiene la lista de Curvas Z-Order con la precisión dada que cubren cada geometría en el conjunto de datos.</p>\n"}]},"apps":[],"jobName":"paragraph_1532728133165_1845623548","id":"20180727-213046_552399077","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:503"},{"text":"val neighborhoods = sqlContext.read\n      .format(\"magellan\")\n      .option(\"type\", \"geojson\")\n      .option(\"magellan.index\", \"true\")\n      .option(\"magellan.index.precision\", \"20\")\n      .load(\"/files/neighborhoods.geojson\")\n      .cache()\n      \nneighborhoods.show()","dateUpdated":"2018-07-27T21:50:20+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"neighborhoods: org.apache.spark.sql.Dataset[org.apache.spark.sql.Row] = [point: point, polyline: polyline ... 4 more fields]\n+-----+--------+--------------------+--------------------+-----+--------------------+\n|point|polyline|             polygon|            metadata|valid|               index|\n+-----+--------+--------------------+--------------------+-----+--------------------+\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-74...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-73...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-74...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-74...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-74...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-73...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-74...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-74...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-74...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-74...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-73...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-74...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-74...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-73...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-73...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-73...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-74...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-74...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-73...|\n| null|    null|magellan.Polygon@...|Map(neighborhood ...| true|[[ZOrderCurve(-74...|\n+-----+--------+--------------------+--------------------+-----+--------------------+\nonly showing top 20 rows\n\n"}]},"apps":[],"jobName":"paragraph_1532728133165_1845623548","id":"20180726-190822_2025080040","dateCreated":"2018-07-27T21:48:53+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:504","user":"anonymous","dateFinished":"2018-07-27T21:50:24+0000","dateStarted":"2018-07-27T21:50:20+0000"},{"text":".printSchema()\n\nneighborhoods.createOrReplaceTempView(\"neighborhoods\")","dateUpdated":"2018-07-27T21:52:59+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"root\n |-- point: point (nullable = true)\n |-- polyline: polyline (nullable = true)\n |-- polygon: polygon (nullable = true)\n |-- metadata: map (nullable = true)\n |    |-- key: string\n |    |-- value: string (valueContainsNull = true)\n |-- valid: boolean (nullable = true)\n |-- index: array (nullable = false)\n |    |-- element: struct (containsNull = true)\n |    |    |-- curve: zordercurve (nullable = false)\n |    |    |-- relation: string (nullable = false)\n\n"}]},"apps":[],"jobName":"paragraph_1532728133166_1846777795","id":"20180727-154313_545680877","dateCreated":"2018-07-27T21:48:53+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:505","user":"anonymous","dateFinished":"2018-07-27T21:50:28+0000","dateStarted":"2018-07-27T21:50:27+0000"},{"text":"%spark2.sql\n\nselect index from neighborhoods limit 7","dateUpdated":"2018-07-27T21:54:04+0000","config":{"colWidth":12,"editorMode":"ace/mode/sql","results":{},"enabled":true,"editorSetting":{"language":"sql"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TABLE","data":"index\nWrappedArray([ZOrderCurve(-74.1796875, 40.78125, -73.828125, 40.95703125, 20, 7335836027405205504, 01100101110011100010),Contains])\nWrappedArray([ZOrderCurve(-73.828125, 40.60546875, -73.4765625, 40.78125, 20, 7335185116521562112, 01100101110010111101),Contains])\nWrappedArray([ZOrderCurve(-74.53125, 40.4296875, -74.1796875, 40.60546875, 20, 7335026786847162368, 01100101110010110100),Intersects], [ZOrderCurve(-74.1796875, 40.4296875, -73.828125, 40.60546875, 20, 7335061971219251200, 01100101110010110110),Intersects])\nWrappedArray([ZOrderCurve(-74.1796875, 40.60546875, -73.828125, 40.78125, 20, 7335079563405295616, 01100101110010110111),Contains])\nWrappedArray([ZOrderCurve(-74.1796875, 40.4296875, -73.828125, 40.60546875, 20, 7335061971219251200, 01100101110010110110),Contains])\nWrappedArray([ZOrderCurve(-73.828125, 40.4296875, -73.4765625, 40.60546875, 20, 7335167524335517696, 01100101110010111100),Contains])\nWrappedArray([ZOrderCurve(-74.1796875, 40.60546875, -73.828125, 40.78125, 20, 7335079563405295616, 01100101110010110111),Contains])\n"}]},"apps":[],"jobName":"paragraph_1532728133166_1846777795","id":"20180727-152924_1326274515","dateCreated":"2018-07-27T21:48:53+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:506","user":"anonymous","dateFinished":"2018-07-27T21:54:04+0000","dateStarted":"2018-07-27T21:54:04+0000"},{"dateUpdated":"2018-07-27T21:48:53+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1532728133166_1846777795","id":"20180726-191404_433097459","dateCreated":"2018-07-27T21:48:53+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:507"}],"name":"Intro","id":"2DK78UFU7","angularObjects":{"2CHS8UYQQ:shared_process":[],"2C8A4SZ9T_livy2:shared_process":[],"2CK8A9MEG:shared_process":[],"2C4U48MY3_spark2:shared_process":[],"2CKAY1A8Y:shared_process":[],"2CKEKWY8Z:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}